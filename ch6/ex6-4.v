//산술 연산자는 이항 연산자와 단항 연산자가 있다. 단항이 우선순위를 가짐
<이항 연산자>
A=4'b0011;B=4'b0100;//A,B는 레지스터 벡터
D=6; E=4;F=2//D,E는 정수

A*b
D/e
A+b
B-a
F=E**

in1=4'b101x;
in2=4'b1010;
sum in1+in2 // sum 결과값이 4'bx임... in1의 값이 명확하지 않으니

-7%2//결과값은 -1. 첫 번째 피연산자의 부호에 따름
7%-2 // 결과값은 +1. 첫 번째 피연산의 부호에 따름

<단항 연산자>
-4
+5
//verilog는 내부적으로 음수를 2의 보수로 나타내고 있음(1의 보수 +1)
//<sss>'<base><nnn> 형태의 수 표현 사용 X
//권장 x
reg [3:0] A=-4;
//권장 o
reg[3:0] A=4'b1100;//-4의 2의 보수 표현

<논리 연산자>
// &&(and)와 ||(or)는 이항 연산자, !(not)는 단항 연산자

<관계 연산자>

<등가 연산자>
a==b // 결과 0,1,x
a!=b // 결과 0,1,x
a===b // 결과 0,1... a와 b에 x나 z와 같은 값이 있어도 0 혹은 1로만
a!==b // 결과 0,1... a와 b에 x나 z와 같은 값이 있어도 0 혹은 1로만

<비트 단위 연산자>
X=4'b1010, Y=4'b1101, Z=4'b10x1
~X // 부정.. 결과값 4'b0101
X&Y //비트단위 AND 결과값 4'b1000
X|Y //비트단위 OR 결과값 4'b1111
X^Y //비트단위 XOR 결과값 4'b0111
X^~Y//비트단위 XNOR 결과값 4'b1000
X&Z//결과값 4'b10x0

//비트단위 연산과 논리 연산의 차이를 아는 것이 중요함
X=4'b1010, Y=4'b000
X|Y//비트단위 연산. 결과값은 4'b1010
X||Y //논리 연산. 결과값은 1

<축소 연산자>
하나의 피연산자만을 취함!
!!오른쪽 비트에서 왼쪽 비트까지 비트별 연산
and(&), nand(~&), or(|), nor(~|), xor(^), xnor(~^,^~)
X=4'b1010
&X //(1&0&1&0) 결과값은 1'b0
|X //(1|0|1|0) 결과값은 1'b1
^X //(1^01^0) 결과값은 1'b0

<자리 이동 연산자>
X=4'b1100
Y=X>>1;//Y는 4'b0110
Y=X<<1;//Y는 4'b1000
Y=X<<2;//4'b0000
//빈자리는 모두 0으로 채워짐

<결합 연산자>
A=1'b1, B=2'b00 ,C=2'b10, D=3'b110
Y={B,C}// 결과값 4'b0010
Y={A,B,C,D,3'b001} // 결과값은 11'b10010110001
Y={A,B[0],C[1]} // 결과값은 3'b101

<중복 연산자>
reg A;
reg[1:0] B,C;
reg[2:0] D;
A=1'b1;B=2'b00;C=2'b010;D=3'b110;
Y={4{A}}// A를 네번 반복... 결과값은 4'b1111
Y={4{A},2{B}}// 결과값은 8'b11110000

<조건 연산자>
3개의 피연산자를 가짐
<조건식? 참 조건식 수식: 거짓 조건시 수식>